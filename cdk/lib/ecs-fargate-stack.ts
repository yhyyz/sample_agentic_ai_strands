import * as cdk from 'aws-cdk-lib';
import * as ec2 from 'aws-cdk-lib/aws-ec2';
import * as ecs from 'aws-cdk-lib/aws-ecs';
import * as ecr from 'aws-cdk-lib/aws-ecr';
import * as iam from 'aws-cdk-lib/aws-iam';
import * as elbv2 from 'aws-cdk-lib/aws-elasticloadbalancingv2';
import * as dynamodb from 'aws-cdk-lib/aws-dynamodb';
import * as secretsmanager from 'aws-cdk-lib/aws-secretsmanager';
import * as logs from 'aws-cdk-lib/aws-logs';
import * as rds from 'aws-cdk-lib/aws-rds';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as customResources from 'aws-cdk-lib/custom-resources';
import { Construct } from 'constructs';

export interface EcsFargateStackProps extends cdk.StackProps {
  namePrefix?: string;
}

export class EcsFargateStack extends cdk.Stack {
  public readonly vpc: ec2.Vpc;
  public readonly cluster: ecs.Cluster;
  public readonly alb: elbv2.ApplicationLoadBalancer;

  constructor(scope: Construct, id: string, props?: EcsFargateStackProps) {
    super(scope, id, props);

    const prefix = props?.namePrefix || 'strands-mcp-app';
    const region = cdk.Stack.of(this).region;
    const isChinaRegion = region.startsWith('cn-');
    // Service principal domain suffix differs between global and China regions
    const servicePrincipalSuffix = isChinaRegion ? 'amazonaws.com.cn' : 'amazonaws.com';
    
    // China regions: cn-north-1 (Beijing), cn-northwest-1 (Ningxia)
    // Log deployment region information
    if (isChinaRegion) {
      cdk.Annotations.of(this).addInfo(`Deploying to China region: ${region}`);
      cdk.Annotations.of(this).addInfo(`Using service principal suffix: ${servicePrincipalSuffix}`);
    }

    // 1. Create VPC with public and private subnets
    this.vpc = new ec2.Vpc(this, `${prefix}-vpc`, {
      ipAddresses: ec2.IpAddresses.cidr('10.0.0.0/16'),
      maxAzs: 2,
      enableDnsHostnames: true,
      enableDnsSupport: true,
      subnetConfiguration: [
        {
          name: 'public',
          subnetType: ec2.SubnetType.PUBLIC,
          cidrMask: 24,
        },
        {
          name: 'private',
          subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
          cidrMask: 24,
        }
      ],
      natGateways: 1,
    });

    // 2. Create DynamoDB table for user configurations
    const userConfigTable = new dynamodb.Table(this, `${prefix}-user-config-table`, {
      // tableName: `${prefix}_user_config_table`,
      partitionKey: {
        name: 'userId',
        type: dynamodb.AttributeType.STRING,
      },
      // 添加 server_id 作为属性而非排序键，除非您的应用真的需要复合主键
      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
      pointInTimeRecovery: true,
      removalPolicy: cdk.RemovalPolicy.DESTROY, // For demo purposes
    });

    // 3. Import existing Secrets Manager secrets (created by deployment script)
    const awsCredentialsSecret = secretsmanager.Secret.fromSecretNameV2(
      this, `${prefix}-aws-credentials`, `${prefix}/aws-credentials`
    );

    const strandsApiKeySecret = secretsmanager.Secret.fromSecretNameV2(
      this, `${prefix}-strands-api-key`, `${prefix}/strands-api-key`
    );

    const strandsApiBaseSecret = secretsmanager.Secret.fromSecretNameV2(
      this, `${prefix}-strands-api-base`, `${prefix}/strands-api-base`
    );

    const langfusePublicKeySecret = secretsmanager.Secret.fromSecretNameV2(
      this, `${prefix}-langfuse-public-key`, `${prefix}/langfuse-public-key`
    );

    const langfuseSecretKeySecret = secretsmanager.Secret.fromSecretNameV2(
      this, `${prefix}-langfuse-secret-key`, `${prefix}/langfuse-secret-key`
    );

    const langfuseHostSecret = secretsmanager.Secret.fromSecretNameV2(
      this, `${prefix}-langfuse-host`, `${prefix}/langfuse-host`
    );

    // Create API key secret (this one is generated by CDK)
    const apiKeySecret = new secretsmanager.Secret(this, `${prefix}-api-key`, {
      secretName: `${prefix}/api-key`,
      description: 'MCP Application API Key',
      generateSecretString: {
        generateStringKey: 'api_key',
        secretStringTemplate: '{}',
        excludeCharacters: '"@/\\',
        includeSpace: false,
        passwordLength: 32,
      },
    });

    // Create DDB table name secret (this references the table created in CDK)
    const ddbTableNameSecret = new secretsmanager.Secret(this, `${prefix}-ddb-table-name`, {
      secretName: `${prefix}/ddb-table-name`,
      description: 'DynamoDB Table Name',
      secretStringValue: cdk.SecretValue.unsafePlainText(userConfigTable.tableName),
    });

    // 4. Import existing ECR repositories (created by deployment script)
    const frontendRepo = ecr.Repository.fromRepositoryName(
      this, `${prefix}-frontend-repo`, `${prefix}-frontend`
    );

    const backendRepo = ecr.Repository.fromRepositoryName(
      this, `${prefix}-backend-repo`, `${prefix}-backend`  
    );

    // 5. Create Security Groups
    const albSecurityGroup = new ec2.SecurityGroup(this, `${prefix}-alb-sg`, {
      vpc: this.vpc,
      description: 'Security group for Application Load Balancer',
      allowAllOutbound: true,
    });

    albSecurityGroup.addIngressRule(
      ec2.Peer.anyIpv4(),
      ec2.Port.tcp(80),
      'Allow HTTP traffic'
    );

    albSecurityGroup.addIngressRule(
      ec2.Peer.anyIpv4(),
      ec2.Port.tcp(443),
      'Allow HTTPS traffic'
    );

    const ecsSecurityGroup = new ec2.SecurityGroup(this, `${prefix}-ecs-sg`, {
      vpc: this.vpc,
      description: 'Security group for ECS tasks',
    });

    ecsSecurityGroup.addIngressRule(
      albSecurityGroup,
      ec2.Port.tcp(3000),
      'Allow traffic from ALB to frontend'
    );

    ecsSecurityGroup.addIngressRule(
      albSecurityGroup,
      ec2.Port.tcp(7002),
      'Allow traffic from ALB to backend'
    );

    ecsSecurityGroup.addEgressRule(
      ec2.Peer.anyIpv4(),
      ec2.Port.tcp(443),
      'Allow HTTPS outbound'
    );


    // 2.5. Create Aurora PostgreSQL Serverless with pg_vector
    // Create DB subnet group for Aurora
    const dbSubnetGroup = new rds.SubnetGroup(this, `${prefix}-db-subnet-group`, {
      description: 'Subnet group for Aurora PostgreSQL',
      vpc: this.vpc,
      vpcSubnets: {
        subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
      },
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });

    // Create security group for Aurora
    const auroraSecurityGroup = new ec2.SecurityGroup(this, `${prefix}-aurora-sg`, {
      vpc: this.vpc,
      description: 'Security group for Aurora PostgreSQL',
      allowAllOutbound: false,
    });

    // Create database credentials secret
    const dbCredentialsSecret = new secretsmanager.Secret(this, `${prefix}-db-credentials`, {
      secretName: `${prefix}/db-credentials`,
      description: 'Aurora PostgreSQL credentials',
      generateSecretString: {
        secretStringTemplate: JSON.stringify({ username: 'postgres' }),
        generateStringKey: 'password',
        excludeCharacters: '"@/\\',
        includeSpace: false,
        passwordLength: 32,
      },
    });

    // Create Aurora PostgreSQL Serverless v2 cluster
    const auroraCluster = new rds.DatabaseCluster(this, `${prefix}-aurora-cluster`, {
      engine: rds.DatabaseClusterEngine.auroraPostgres({
        version: rds.AuroraPostgresEngineVersion.VER_15_4,
      }),
      credentials: rds.Credentials.fromSecret(dbCredentialsSecret),
      defaultDatabaseName: 'mcpapp',
      vpc: this.vpc,
      vpcSubnets: {
        subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
      },
      subnetGroup: dbSubnetGroup,
      securityGroups: [auroraSecurityGroup],
      // parameterGroup: dbParameterGroup,
      serverlessV2MinCapacity: 0.5,
      serverlessV2MaxCapacity: 4,
      writer: rds.ClusterInstance.serverlessV2(`${prefix}-writer`, {
        publiclyAccessible: false,
      }),
      readers: [
        rds.ClusterInstance.serverlessV2(`${prefix}-reader`, {
          publiclyAccessible: false,
        }),
      ],
      backup: {
        retention: cdk.Duration.days(7),
        preferredWindow: '03:00-04:00',
      },
      preferredMaintenanceWindow: 'sun:04:00-sun:05:00',
      deletionProtection: false, // For demo purposes
      removalPolicy: cdk.RemovalPolicy.DESTROY, // For demo purposes
    });

    // Create database connection info secret
    const dbConnectionSecret = new secretsmanager.Secret(this, `${prefix}-db-connection`, {
      secretName: `${prefix}/db-connection`,
      description: 'Aurora PostgreSQL connection information',
      secretStringValue: cdk.SecretValue.unsafePlainText(JSON.stringify({
        host: auroraCluster.clusterEndpoint.hostname,
        port: auroraCluster.clusterEndpoint.port,
        database: 'mcpapp',
        username: 'postgres',
      })),
    });

     ecsSecurityGroup.addEgressRule(
      ec2.Peer.anyIpv4(),
      ec2.Port.tcp(443),
      'Allow HTTPS outbound'
    );

    // Allow ECS tasks to connect to Aurora PostgreSQL
    auroraSecurityGroup.addIngressRule(
      ecsSecurityGroup,
      ec2.Port.tcp(5432),
      'Allow ECS tasks to connect to PostgreSQL'
    );

    // Create Lambda security group for database initialization
    const lambdaSecurityGroup = new ec2.SecurityGroup(this, `${prefix}-lambda-sg`, {
      vpc: this.vpc,
      description: 'Security group for Lambda function to initialize database',
      allowAllOutbound: true,
    });

    // Allow Lambda to connect to Aurora PostgreSQL
    auroraSecurityGroup.addIngressRule(
      lambdaSecurityGroup,
      ec2.Port.tcp(5432),
      'Allow Lambda to connect to PostgreSQL for initialization'
    );

    // 6. Create Application Load Balancer
    this.alb = new elbv2.ApplicationLoadBalancer(this, `${prefix}-alb`, {
      vpc: this.vpc,
      internetFacing: true,
      securityGroup: albSecurityGroup,
    });

    // 7. Create Target Groups
    const frontendTargetGroup = new elbv2.ApplicationTargetGroup(this, `${prefix}-frontend-tg`, {
      port: 3000,
      protocol: elbv2.ApplicationProtocol.HTTP,
      vpc: this.vpc,
      targetType: elbv2.TargetType.IP,
      // Disable stickiness to avoid SameSite cookie issues over HTTP
      // stickinessCookieDuration: cdk.Duration.hours(24),
      healthCheck: {
        path: '/chat',
        healthyHttpCodes: '200',
        interval: cdk.Duration.seconds(60),
        timeout: cdk.Duration.seconds(5),
        healthyThresholdCount: 2,
        unhealthyThresholdCount: 5,
      },
    });

    const backendTargetGroup = new elbv2.ApplicationTargetGroup(this, `${prefix}-backend-tg`, {
      port: 7002,
      protocol: elbv2.ApplicationProtocol.HTTP,
      vpc: this.vpc,
      targetType: elbv2.TargetType.IP,
      // Disable stickiness to avoid SameSite cookie issues over HTTP
      // stickinessCookieDuration: cdk.Duration.hours(24),
      healthCheck: {
        path: '/api/health',
        healthyHttpCodes: '200',
        interval: cdk.Duration.seconds(60),
        timeout: cdk.Duration.seconds(5),
        healthyThresholdCount: 2,
        unhealthyThresholdCount: 5,
      },
    });

    // 8. Create ALB Listener with routing rules
    const listener = this.alb.addListener(`${prefix}-listener`, {
      port: 80,
      protocol: elbv2.ApplicationProtocol.HTTP,
      defaultTargetGroups: [frontendTargetGroup],
    });

    listener.addTargetGroups(`${prefix}-backend-rule-v1`, {
      priority: 100,
      conditions: [
        elbv2.ListenerCondition.pathPatterns(['/v1/*'])
      ],
      targetGroups: [backendTargetGroup],
    });

    listener.addTargetGroups(`${prefix}-backend-rule-health`, {
      priority: 201,
      conditions: [
        elbv2.ListenerCondition.pathPatterns(['/api/health'])
      ],
      targetGroups: [backendTargetGroup],
    });

    // 9. Create ECS Cluster
    this.cluster = new ecs.Cluster(this, `${prefix}-cluster`, {
      vpc: this.vpc,
      clusterName: `${prefix}-cluster`,
      containerInsightsV2: ecs.ContainerInsights.ENABLED,
    });

    // 10. Create CloudWatch Log Groups
    const frontendLogGroup = new logs.LogGroup(this, `${prefix}-frontend-logs`, {
      logGroupName: `/ecs/${prefix}-frontend`,
      retention: logs.RetentionDays.ONE_WEEK,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });

    const backendLogGroup = new logs.LogGroup(this, `${prefix}-backend-logs`, {
      logGroupName: `/ecs/${prefix}-backend`,
      retention: logs.RetentionDays.ONE_WEEK,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });

    // 11. Create IAM Roles
    const taskExecutionRole = new iam.Role(this, `${prefix}-task-execution-role`, {
      assumedBy: new iam.ServicePrincipal(`ecs-tasks.${servicePrincipalSuffix}`),
      managedPolicies: [
        iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AmazonECSTaskExecutionRolePolicy'),
      ],
    });

    // Add permissions to access Secrets Manager
    taskExecutionRole.addToPolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        'secretsmanager:GetSecretValue',
      ],
      resources: [
        apiKeySecret.secretArn,
        awsCredentialsSecret.secretArn,
        strandsApiKeySecret.secretArn,
        strandsApiBaseSecret.secretArn,
        langfusePublicKeySecret.secretArn,
        langfuseSecretKeySecret.secretArn,
        langfuseHostSecret.secretArn,
        ddbTableNameSecret.secretArn,
        dbCredentialsSecret.secretArn,
        dbConnectionSecret.secretArn,
      ],
    }));

    const taskRole = new iam.Role(this, `${prefix}-task-role`, {
      assumedBy: new iam.ServicePrincipal(`ecs-tasks.${servicePrincipalSuffix}`),
    });

    // Add permissions for backend tasks
    // Note: Bedrock may not be available in China regions
    if (!isChinaRegion) {
      taskRole.addToPolicy(new iam.PolicyStatement({
        effect: iam.Effect.ALLOW,
        actions: [
          'bedrock:InvokeModel',
          'bedrock:InvokeModelWithResponseStream',
          'bedrock:ListFoundationModels',
        ],
        resources: ['*'],
      }));
    } else {
      cdk.Annotations.of(this).addWarning('Bedrock permissions skipped for China region - service not be available');
    }

    taskRole.addToPolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        'dynamodb:GetItem',
        'dynamodb:PutItem',
        'dynamodb:UpdateItem',
        'dynamodb:DeleteItem',
        'dynamodb:Query',
        'dynamodb:Scan',
      ],
      resources: [userConfigTable.tableArn],
    }));

    taskRole.addToPolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        'sts:GetCallerIdentity'
      ],
      resources: ["*"],
    }));

    taskRole.addToPolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        'secretsmanager:GetSecretValue',
      ],
      resources: [
        apiKeySecret.secretArn,
        awsCredentialsSecret.secretArn,
        strandsApiKeySecret.secretArn,
        strandsApiBaseSecret.secretArn,
        langfusePublicKeySecret.secretArn,
        langfuseSecretKeySecret.secretArn,
        langfuseHostSecret.secretArn,
        ddbTableNameSecret.secretArn,
        dbCredentialsSecret.secretArn,
        dbConnectionSecret.secretArn,
      ],
    }));

    // Add S3 permissions for bucket creation and write operations
    // S3 ARN format differs between global and China regions
    const s3ArnPrefix = isChinaRegion ? 'arn:aws-cn:s3:::' : 'arn:aws:s3:::';
    
    taskRole.addToPolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        's3:CreateBucket',
        's3:PutBucketPolicy',
        's3:PutBucketAcl',
        's3:PutBucketCors',
        's3:PutBucketNotification',
        's3:PutBucketTagging',
        's3:PutBucketVersioning',
        's3:PutBucketLogging',
        's3:ListBucket',
        's3:ListAllMyBuckets',
      ],
      resources: [`${s3ArnPrefix}*`], // For bucket operations with correct ARN format
    }));

    taskRole.addToPolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        's3:PutObject',
        's3:PutObjectAcl',
        's3:PutObjectTagging',
        's3:GetObject',
        's3:GetObjectAcl',
        's3:DeleteObject',
        's3:AbortMultipartUpload',
        's3:ListMultipartUploadParts',
      ],
      resources: [`${s3ArnPrefix}*/*`], // For object operations with correct ARN format
    }));

    // 12. Create Frontend Task Definition
    const frontendTaskDefinition = new ecs.FargateTaskDefinition(this, `${prefix}-frontend-task`, {
      memoryLimitMiB: 512*2,
      cpu: 256*2,
      taskRole: taskRole,
      executionRole: taskExecutionRole,
      runtimePlatform: {
        cpuArchitecture: ecs.CpuArchitecture.ARM64,
        operatingSystemFamily: ecs.OperatingSystemFamily.LINUX,
      },
    });

    const frontendContainer = frontendTaskDefinition.addContainer(`${prefix}-frontend-container`, {
      image: ecs.ContainerImage.fromEcrRepository(frontendRepo, 'latest'),
      memoryLimitMiB: 512,
      environment: {
        NODE_ENV: 'production',
        SERVER_MCP_BASE_URL: `http://${this.alb.loadBalancerDnsName}`,
        NEXT_PUBLIC_MCP_BASE_URL: '/api',
        
      },
      secrets: {
        NEXT_PUBLIC_API_KEY: ecs.Secret.fromSecretsManager(apiKeySecret,'api_key')
      },
      logging: ecs.LogDrivers.awsLogs({
        streamPrefix: 'ecs',
        logGroup: frontendLogGroup,
      }),
      healthCheck: {
        command: ['CMD-SHELL', 'curl -f http://localhost:3000/chat || exit 1'],
        interval: cdk.Duration.seconds(30),
        timeout: cdk.Duration.seconds(5),
        retries: 3,
        startPeriod: cdk.Duration.seconds(60),
      },
    });

    frontendContainer.addPortMappings({
      containerPort: 3000,
      protocol: ecs.Protocol.TCP,
    });

    // 13. Create Backend Task Definition
    const backendTaskDefinition = new ecs.FargateTaskDefinition(this, `${prefix}-backend-task`, {
      memoryLimitMiB: 1024*4,
      cpu: 512*4,
      executionRole: taskExecutionRole,
      taskRole: taskRole,
      runtimePlatform: {
        cpuArchitecture: ecs.CpuArchitecture.ARM64,
        operatingSystemFamily: ecs.OperatingSystemFamily.LINUX,
      },
    });

    const backendContainer = backendTaskDefinition.addContainer(`${prefix}-backend-container`, {
      image: ecs.ContainerImage.fromEcrRepository(backendRepo, 'latest'),
      memoryLimitMiB: 1024*4,
      environment: {
        AWS_REGION: cdk.Stack.of(this).region,
        STRANDS_MODEL_PROVIDER: process.env.STRANDS_MODEL_PROVIDER||'bedrock',
        MAX_TURNS: '200',
        INACTIVE_TIME: process.env.INACTIVE_TIME||'1440',
        CLIENT_TYPE: 'strands',
        LOG_DIR: './logs',
        MCP_SERVICE_HOST: '0.0.0.0',
        MCP_SERVICE_PORT: '7002',
        USE_HTTPS: '0',
        ddb_table:userConfigTable.tableName,
        LANGFUSE_HOST:process.env.LANGFUSE_HOST||'',
        // AWS_ACCESS_KEY_ID:process.env.AWS_ACCESS_KEY_ID || "",
        // AWS_SECRET_ACCESS_KEY:process.env.AWS_SECRET_ACCESS_KEY || "",
        // OPENAI_BASE_URL:process.env.OPENAI_BASE_URL ||"",
        // OPENAI_API_KEY:process.env.OPENAI_API_KEY||"",
        LANGFUSE_PUBLIC_KEY:process.env.LANGFUSE_PUBLIC_KEY || "",
        LANGFUSE_SECRET_KEY:process.env.LANGFUSE_SECRET_KEY || "",
        // Mem0 configuration
        POSTGRESQL_HOST: auroraCluster.clusterEndpoint.hostname,
        POSTGRESQL_PORT: auroraCluster.clusterEndpoint.port.toString(),
        DB_NAME: 'mcpapp',
        BYPASS_TOOL_CONSENT:'true',
        LLM_MODEL:process.env.LLM_MODEL||"Qwen/Qwen3-14B",
        EMBEDDING_MODEL:process.env.EMBEDDING_MODEL ||"Pro/BAAI/bge-m3"

      },
      secrets: {
        API_KEY: ecs.Secret.fromSecretsManager(apiKeySecret,'api_key'),
        // Database credentials
        POSTGRESQL_USER: ecs.Secret.fromSecretsManager(dbCredentialsSecret,'username'),
        POSTGRESQL_PASSWORD: ecs.Secret.fromSecretsManager(dbCredentialsSecret,'password'),
        AWS_ACCESS_KEY_ID: ecs.Secret.fromSecretsManager(awsCredentialsSecret, 'AccessKeyId'),
        AWS_SECRET_ACCESS_KEY: ecs.Secret.fromSecretsManager(awsCredentialsSecret, 'SecretAccessKey'),
        OPENAI_API_KEY: ecs.Secret.fromSecretsManager(strandsApiKeySecret),
        OPENAI_BASE_URL: ecs.Secret.fromSecretsManager(strandsApiBaseSecret),
        // LANGFUSE_PUBLIC_KEY: ecs.Secret.fromSecretsManager(langfusePublicKeySecret),
        // LANGFUSE_SECRET_KEY: ecs.Secret.fromSecretsManager(langfuseSecretKeySecret),
        // LANGFUSE_HOST:ecs.Secret.fromSecretsManager(langfuseHostSecret),
        // ddb_table: ecs.Secret.fromSecretsManager(ddbTableNameSecret),
      },
      logging: ecs.LogDrivers.awsLogs({
        streamPrefix: 'ecs',
        logGroup: backendLogGroup,
      }),
      healthCheck: {
        command: ['CMD-SHELL', 'curl -f http://localhost:7002/api/health || exit 1'],
        interval: cdk.Duration.seconds(30),
        timeout: cdk.Duration.seconds(5),
        retries: 3,
        startPeriod: cdk.Duration.seconds(60),
      },
    });

    backendContainer.addPortMappings({
      containerPort: 7002,
      protocol: ecs.Protocol.TCP,
    });

    // 14. Create ECS Services
    const frontendService = new ecs.FargateService(this, `${prefix}-frontend-service`, {
      cluster: this.cluster,
      taskDefinition: frontendTaskDefinition,
      desiredCount: 2,
      assignPublicIp: false,
      vpcSubnets: {
        subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
      },
      securityGroups: [ecsSecurityGroup],
      platformVersion: ecs.FargatePlatformVersion.LATEST,
    });

    const backendService = new ecs.FargateService(this, `${prefix}-backend-service`, {
      cluster: this.cluster,
      taskDefinition: backendTaskDefinition,
      desiredCount: 2,
      assignPublicIp: false,
      vpcSubnets: {
        subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
      },
      securityGroups: [ecsSecurityGroup],
      platformVersion: ecs.FargatePlatformVersion.LATEST,
    });

    // 15. Attach services to target groups
    frontendService.attachToApplicationTargetGroup(frontendTargetGroup);
    backendService.attachToApplicationTargetGroup(backendTargetGroup);

    // 16. Enable Auto Scaling for services
    const frontendScaling = frontendService.autoScaleTaskCount({
      minCapacity: 2,
      maxCapacity: 10,
    });

    frontendScaling.scaleOnCpuUtilization(`${prefix}-frontend-cpu-scaling`, {
      targetUtilizationPercent: 70,
      scaleInCooldown: cdk.Duration.seconds(300),
      scaleOutCooldown: cdk.Duration.seconds(300),
    });

    const backendScaling = backendService.autoScaleTaskCount({
      minCapacity: 2,
      maxCapacity: 10,
    });

    backendScaling.scaleOnCpuUtilization(`${prefix}-backend-cpu-scaling`, {
      targetUtilizationPercent: 70,
      scaleInCooldown: cdk.Duration.seconds(300),
      scaleOutCooldown: cdk.Duration.seconds(300),
    });

    // 17. Stack Outputs
    new cdk.CfnOutput(this, 'VpcId', {
      value: this.vpc.vpcId,
      description: 'VPC ID',
    });

    new cdk.CfnOutput(this, 'ClusterName', {
      value: this.cluster.clusterName,
      description: 'ECS Cluster Name',
    });

    new cdk.CfnOutput(this, 'AlbDnsName', {
      value: this.alb.loadBalancerDnsName,
      description: 'Application Load Balancer DNS Name',
    });

    new cdk.CfnOutput(this, 'FrontendUrl', {
      value: `http://${this.alb.loadBalancerDnsName}`,
      description: 'Frontend Application URL',
    });

    new cdk.CfnOutput(this, 'BackendApiUrl', {
      value: `http://${this.alb.loadBalancerDnsName}/api`,
      description: 'Backend API URL',
    });

    new cdk.CfnOutput(this, 'DynamoDbTableName', {
      value: userConfigTable.tableName,
      description: 'DynamoDB Table Name',
    });

    new cdk.CfnOutput(this, 'FrontendEcrRepository', {
      value: frontendRepo.repositoryUri,
      description: 'Frontend ECR Repository URI',
    });

    new cdk.CfnOutput(this, 'BackendEcrRepository', {
      value: backendRepo.repositoryUri,
      description: 'Backend ECR Repository URI',
    });

    new cdk.CfnOutput(this, 'SecretsManagerPrefix', {
      value: `${prefix}/`,
      description: 'Secrets Manager secrets prefix',
    });
     new cdk.CfnOutput(this, 'AuroraClusterEndpoint', {
      value: auroraCluster.clusterEndpoint.hostname,
      description: 'Aurora PostgreSQL cluster endpoint',
    });

    new cdk.CfnOutput(this, 'AuroraClusterPort', {
      value: auroraCluster.clusterEndpoint.port.toString(),
      description: 'Aurora PostgreSQL cluster port',
    });

    new cdk.CfnOutput(this, 'DatabaseName', {
      value: 'mcpapp',
      description: 'Aurora PostgreSQL database name',
    });
  }
}

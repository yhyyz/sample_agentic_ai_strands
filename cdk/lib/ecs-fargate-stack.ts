import * as cdk from 'aws-cdk-lib';
import * as ec2 from 'aws-cdk-lib/aws-ec2';
import * as ecs from 'aws-cdk-lib/aws-ecs';
import * as ecr from 'aws-cdk-lib/aws-ecr';
import * as iam from 'aws-cdk-lib/aws-iam';
import * as elbv2 from 'aws-cdk-lib/aws-elasticloadbalancingv2';
import * as dynamodb from 'aws-cdk-lib/aws-dynamodb';
import * as secretsmanager from 'aws-cdk-lib/aws-secretsmanager';
import * as logs from 'aws-cdk-lib/aws-logs';
import * as rds from 'aws-cdk-lib/aws-rds';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as customResources from 'aws-cdk-lib/custom-resources';
import { Construct } from 'constructs';

export interface EcsFargateStackProps extends cdk.StackProps {
  namePrefix?: string;
  enableMem0?: boolean;
}

export class EcsFargateStack extends cdk.Stack {
  public readonly vpc: ec2.Vpc;
  public readonly cluster: ecs.Cluster;
  public readonly alb: elbv2.ApplicationLoadBalancer;

  constructor(scope: Construct, id: string, props?: EcsFargateStackProps) {
    super(scope, id, props);

    const prefix = props?.namePrefix || 'strands-mcp-app';
    const region = cdk.Stack.of(this).region;
    const isChinaRegion = region.startsWith('cn-');
    // Service principal domain suffix differs between global and China regions
    const servicePrincipalSuffix = isChinaRegion ? 'amazonaws.com.cn' : 'amazonaws.com';
    
    // Determine CPU architecture based on PLATFORM environment variable
    const platform = process.env.PLATFORM || 'linux/arm64'; // Default to ARM64
    let cpuArchitecture: ecs.CpuArchitecture;
    
    if (platform === 'linux/arm64') {
      cpuArchitecture = ecs.CpuArchitecture.ARM64;
    } else if (platform === 'linux/amd64') {
      cpuArchitecture = ecs.CpuArchitecture.X86_64;
    } else {
      // Default fallback
      cpuArchitecture = ecs.CpuArchitecture.ARM64;
      cdk.Annotations.of(this).addWarning(`Unknown platform '${platform}', defaulting to ARM64`);
    }
    
    // China regions: cn-north-1 (Beijing), cn-northwest-1 (Ningxia)
    // Log deployment region information
    if (isChinaRegion) {
      cdk.Annotations.of(this).addInfo(`Deploying to China region: ${region}`);
      cdk.Annotations.of(this).addInfo(`Using service principal suffix: ${servicePrincipalSuffix}`);
    }

    // 1. Create VPC with public and private subnets
    this.vpc = new ec2.Vpc(this, `${prefix}-vpc`, {
      ipAddresses: ec2.IpAddresses.cidr('10.0.0.0/16'),
      maxAzs: 2,
      enableDnsHostnames: true,
      enableDnsSupport: true,
      subnetConfiguration: [
        {
          name: 'public',
          subnetType: ec2.SubnetType.PUBLIC,
          cidrMask: 24,
        },
        {
          name: 'private',
          subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
          cidrMask: 24,
        }
      ],
      natGateways: 1,
    });

    // 2. Create DynamoDB table for user configurations
    const userConfigTable = new dynamodb.Table(this, `${prefix}-user-config-table`, {
      // tableName: `${prefix}_user_config_table`,
      partitionKey: {
        name: 'userId',
        type: dynamodb.AttributeType.STRING,
      },
      // 添加 server_id 作为属性而非排序键，除非您的应用真的需要复合主键
      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
      pointInTimeRecovery: true,
      removalPolicy: cdk.RemovalPolicy.DESTROY, // For demo purposes
    });

    // 3. Import existing Secrets Manager secrets (created by deployment script)
    const awsCredentialsSecret = secretsmanager.Secret.fromSecretNameV2(
      this, `${prefix}-aws-credentials`, `${prefix}/aws-credentials`
    );

    const bedrockAwsCredentialsSecret = secretsmanager.Secret.fromSecretNameV2(
      this, `${prefix}-bedrock-aws-credentials`, `${prefix}/bedrock-aws-credentials`
    );

    const strandsApiKeySecret = secretsmanager.Secret.fromSecretNameV2(
      this, `${prefix}-strands-api-key`, `${prefix}/strands-api-key`
    );

    const strandsApiBaseSecret = secretsmanager.Secret.fromSecretNameV2(
      this, `${prefix}-strands-api-base`, `${prefix}/strands-api-base`
    );

    const langfusePublicKeySecret = secretsmanager.Secret.fromSecretNameV2(
      this, `${prefix}-langfuse-public-key`, `${prefix}/langfuse-public-key`
    );

    const langfuseSecretKeySecret = secretsmanager.Secret.fromSecretNameV2(
      this, `${prefix}-langfuse-secret-key`, `${prefix}/langfuse-secret-key`
    );

    const langfuseHostSecret = secretsmanager.Secret.fromSecretNameV2(
      this, `${prefix}-langfuse-host`, `${prefix}/langfuse-host`
    );

    // Create API key secret (this one is generated by CDK)
    const apiKeySecret = new secretsmanager.Secret(this, `${prefix}-api-key`, {
      secretName: `${prefix}/api-key`,
      description: 'MCP Application API Key',
      generateSecretString: {
        generateStringKey: 'api_key',
        secretStringTemplate: '{}',
        excludeCharacters: '"@/\\',
        includeSpace: false,
        passwordLength: 32,
      },
    });

    // Create DDB table name secret (this references the table created in CDK)
    const ddbTableNameSecret = new secretsmanager.Secret(this, `${prefix}-ddb-table-name`, {
      secretName: `${prefix}/ddb-table-name`,
      description: 'DynamoDB Table Name',
      secretStringValue: cdk.SecretValue.unsafePlainText(userConfigTable.tableName),
    });

    // 4. Import existing ECR repositories (created by deployment script)
    const frontendRepo = ecr.Repository.fromRepositoryName(
      this, `${prefix}-frontend-repo`, `${prefix}-frontend`
    );

    const backendRepo = ecr.Repository.fromRepositoryName(
      this, `${prefix}-backend-repo`, `${prefix}-backend`  
    );

    // 5. Create Security Groups
    const albSecurityGroup = new ec2.SecurityGroup(this, `${prefix}-alb-sg`, {
      vpc: this.vpc,
      description: 'Security group for Application Load Balancer',
      allowAllOutbound: true,
    });

    albSecurityGroup.addIngressRule(
      ec2.Peer.anyIpv4(),
      ec2.Port.tcp(80),
      'Allow HTTP traffic'
    );

    albSecurityGroup.addIngressRule(
      ec2.Peer.anyIpv4(),
      ec2.Port.tcp(443),
      'Allow HTTPS traffic'
    );

    const ecsSecurityGroup = new ec2.SecurityGroup(this, `${prefix}-ecs-sg`, {
      vpc: this.vpc,
      description: 'Security group for ECS tasks',
    });

    ecsSecurityGroup.addIngressRule(
      albSecurityGroup,
      ec2.Port.tcp(3000),
      'Allow traffic from ALB to frontend'
    );

    ecsSecurityGroup.addIngressRule(
      albSecurityGroup,
      ec2.Port.tcp(7002),
      'Allow traffic from ALB to backend'
    );

    ecsSecurityGroup.addEgressRule(
      ec2.Peer.anyIpv4(),
      ec2.Port.tcp(443),
      'Allow HTTPS outbound'
    );


    // Check if Mem0 (Aurora) should be enabled
    const enableMem0 = props?.enableMem0 ?? true; // Default to true for backward compatibility
    
    // Mem0 Aurora-related resources (conditional)
    let dbCredentialsSecret: secretsmanager.Secret | undefined;
    let dbConnectionSecret: secretsmanager.Secret | undefined;
    let auroraCluster: rds.DatabaseCluster | undefined;
    let auroraSecurityGroup: ec2.SecurityGroup | undefined;
    let lambdaSecurityGroup: ec2.SecurityGroup | undefined;

    if (enableMem0) {
      // 2.5. Create Aurora PostgreSQL Serverless with pg_vector for Mem0
      // Create DB subnet group for Aurora
      const dbSubnetGroup = new rds.SubnetGroup(this, `${prefix}-db-subnet-group`, {
        description: 'Subnet group for Aurora PostgreSQL',
        vpc: this.vpc,
        vpcSubnets: {
          subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
        },
        removalPolicy: cdk.RemovalPolicy.DESTROY,
      });

      // Create security group for Aurora
      auroraSecurityGroup = new ec2.SecurityGroup(this, `${prefix}-aurora-sg`, {
        vpc: this.vpc,
        description: 'Security group for Aurora PostgreSQL',
        allowAllOutbound: false,
      });

      // Create database credentials secret
      dbCredentialsSecret = new secretsmanager.Secret(this, `${prefix}-db-credentials`, {
        secretName: `${prefix}/db-credentials`,
        description: 'Aurora PostgreSQL credentials',
        generateSecretString: {
          secretStringTemplate: JSON.stringify({ username: 'postgres' }),
          generateStringKey: 'password',
          excludeCharacters: '"@/\\',
          includeSpace: false,
          passwordLength: 32,
        },
      });

      // Create Aurora PostgreSQL Serverless v2 cluster
      auroraCluster = new rds.DatabaseCluster(this, `${prefix}-aurora-cluster`, {
        engine: rds.DatabaseClusterEngine.auroraPostgres({
          version: rds.AuroraPostgresEngineVersion.VER_15_4,
        }),
        credentials: rds.Credentials.fromSecret(dbCredentialsSecret),
        defaultDatabaseName: 'mcpapp',
        vpc: this.vpc,
        vpcSubnets: {
          subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
        },
        subnetGroup: dbSubnetGroup,
        securityGroups: [auroraSecurityGroup],
        // parameterGroup: dbParameterGroup,
        serverlessV2MinCapacity: 0.5,
        serverlessV2MaxCapacity: 4,
        writer: rds.ClusterInstance.serverlessV2(`${prefix}-writer`, {
          publiclyAccessible: false,
        }),
        readers: [
          rds.ClusterInstance.serverlessV2(`${prefix}-reader`, {
            publiclyAccessible: false,
          }),
        ],
        backup: {
          retention: cdk.Duration.days(7),
          preferredWindow: '03:00-04:00',
        },
        preferredMaintenanceWindow: 'sun:04:00-sun:05:00',
        deletionProtection: false, // For demo purposes
        removalPolicy: cdk.RemovalPolicy.DESTROY, // For demo purposes
      });

      // Create database connection info secret
      dbConnectionSecret = new secretsmanager.Secret(this, `${prefix}-db-connection`, {
        secretName: `${prefix}/db-connection`,
        description: 'Aurora PostgreSQL connection information',
        secretStringValue: cdk.SecretValue.unsafePlainText(JSON.stringify({
          host: auroraCluster.clusterEndpoint.hostname,
          port: auroraCluster.clusterEndpoint.port,
          database: 'mcpapp',
          username: 'postgres',
        })),
      });

      // Allow ECS tasks to connect to Aurora PostgreSQL
      auroraSecurityGroup.addIngressRule(
        ecsSecurityGroup,
        ec2.Port.tcp(5432),
        'Allow ECS tasks to connect to PostgreSQL'
      );

      // Create Lambda security group for database initialization
      lambdaSecurityGroup = new ec2.SecurityGroup(this, `${prefix}-lambda-sg`, {
        vpc: this.vpc,
        description: 'Security group for Lambda function to initialize database',
        allowAllOutbound: true,
      });

      // Allow Lambda to connect to Aurora PostgreSQL
      auroraSecurityGroup.addIngressRule(
        lambdaSecurityGroup,
        ec2.Port.tcp(5432),
        'Allow Lambda to connect to PostgreSQL for initialization'
      );
    }

    ecsSecurityGroup.addEgressRule(
      ec2.Peer.anyIpv4(),
      ec2.Port.tcp(443),
      'Allow HTTPS outbound'
    );

    // 6. Create Application Load Balancer
    this.alb = new elbv2.ApplicationLoadBalancer(this, `${prefix}-alb`, {
      vpc: this.vpc,
      internetFacing: true,
      securityGroup: albSecurityGroup,
    });

    // 7. Create Target Groups
    const frontendTargetGroup = new elbv2.ApplicationTargetGroup(this, `${prefix}-frontend-tg`, {
      port: 3000,
      protocol: elbv2.ApplicationProtocol.HTTP,
      vpc: this.vpc,
      targetType: elbv2.TargetType.IP,
      // Disable stickiness to avoid SameSite cookie issues over HTTP
      // stickinessCookieDuration: cdk.Duration.hours(24),
      healthCheck: {
        path: '/chat',
        healthyHttpCodes: '200',
        interval: cdk.Duration.seconds(60),
        timeout: cdk.Duration.seconds(5),
        healthyThresholdCount: 2,
        unhealthyThresholdCount: 5,
      },
    });

    const backendTargetGroup = new elbv2.ApplicationTargetGroup(this, `${prefix}-backend-tg`, {
      port: 7002,
      protocol: elbv2.ApplicationProtocol.HTTP,
      vpc: this.vpc,
      targetType: elbv2.TargetType.IP,
      // Disable stickiness to avoid SameSite cookie issues over HTTP
      // stickinessCookieDuration: cdk.Duration.hours(24),
      healthCheck: {
        path: '/api/health',
        healthyHttpCodes: '200',
        interval: cdk.Duration.seconds(60),
        timeout: cdk.Duration.seconds(5),
        healthyThresholdCount: 2,
        unhealthyThresholdCount: 5,
      },
    });

    // 8. Create ALB Listener with routing rules
    const listener = this.alb.addListener(`${prefix}-listener`, {
      port: 80,
      protocol: elbv2.ApplicationProtocol.HTTP,
      defaultTargetGroups: [frontendTargetGroup],
    });

    listener.addTargetGroups(`${prefix}-backend-rule-v1`, {
      priority: 100,
      conditions: [
        elbv2.ListenerCondition.pathPatterns(['/v1/*'])
      ],
      targetGroups: [backendTargetGroup],
    });

    listener.addTargetGroups(`${prefix}-backend-rule-health`, {
      priority: 201,
      conditions: [
        elbv2.ListenerCondition.pathPatterns(['/api/health'])
      ],
      targetGroups: [backendTargetGroup],
    });

    // 9. Create ECS Cluster
    this.cluster = new ecs.Cluster(this, `${prefix}-cluster`, {
      vpc: this.vpc,
      clusterName: `${prefix}-cluster`,
      containerInsightsV2: ecs.ContainerInsights.ENABLED,
    });

    // 10. Create CloudWatch Log Groups
    const frontendLogGroup = new logs.LogGroup(this, `${prefix}-frontend-logs`, {
      logGroupName: `/ecs/${prefix}-frontend`,
      retention: logs.RetentionDays.ONE_WEEK,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });

    const backendLogGroup = new logs.LogGroup(this, `${prefix}-backend-logs`, {
      logGroupName: `/ecs/${prefix}-backend`,
      retention: logs.RetentionDays.ONE_WEEK,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });

    // 11. Create IAM Roles
    const taskExecutionRole = new iam.Role(this, `${prefix}-task-execution-role`, {
      assumedBy: new iam.ServicePrincipal(`ecs-tasks.${servicePrincipalSuffix}`),
      managedPolicies: [
        iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AmazonECSTaskExecutionRolePolicy'),
      ],
    });

    // Add permissions to access Secrets Manager
    const secretsManagerResources = [
      apiKeySecret.secretArn,
      awsCredentialsSecret.secretArn,
      bedrockAwsCredentialsSecret.secretArn,
      strandsApiKeySecret.secretArn,
      strandsApiBaseSecret.secretArn,
      langfusePublicKeySecret.secretArn,
      langfuseSecretKeySecret.secretArn,
      langfuseHostSecret.secretArn,
      ddbTableNameSecret.secretArn,
    ];

    // Add Aurora secrets only if Mem0 is enabled
    if (enableMem0 && dbCredentialsSecret && dbConnectionSecret) {
      secretsManagerResources.push(dbCredentialsSecret.secretArn, dbConnectionSecret.secretArn);
    }

    taskExecutionRole.addToPolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        'secretsmanager:GetSecretValue',
      ],
      resources: secretsManagerResources,
    }));

    const taskRole = new iam.Role(this, `${prefix}-task-role`, {
      assumedBy: new iam.ServicePrincipal(`ecs-tasks.${servicePrincipalSuffix}`),
    });

    // Add permissions for backend tasks
    // Note: Bedrock may not be available in China regions
    if (!isChinaRegion) {
      taskRole.addToPolicy(new iam.PolicyStatement({
        effect: iam.Effect.ALLOW,
        actions: [
          'bedrock:InvokeModel',
          'bedrock:InvokeModelWithResponseStream',
          'bedrock:ListFoundationModels',
        ],
        resources: ['*'],
      }));
    } else {
      cdk.Annotations.of(this).addWarning('Bedrock permissions skipped for China region - service not be available');
    }

    taskRole.addToPolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        'dynamodb:GetItem',
        'dynamodb:PutItem',
        'dynamodb:UpdateItem',
        'dynamodb:DeleteItem',
        'dynamodb:Query',
        'dynamodb:Scan',
      ],
      resources: [userConfigTable.tableArn],
    }));

    taskRole.addToPolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        'sts:GetCallerIdentity'
      ],
      resources: ["*"],
    }));

    const taskRoleSecretsManagerResources = [
      apiKeySecret.secretArn,
      awsCredentialsSecret.secretArn,
      bedrockAwsCredentialsSecret.secretArn,
      strandsApiKeySecret.secretArn,
      strandsApiBaseSecret.secretArn,
      langfusePublicKeySecret.secretArn,
      langfuseSecretKeySecret.secretArn,
      langfuseHostSecret.secretArn,
      ddbTableNameSecret.secretArn,
    ];

    // Add Aurora secrets only if Mem0 is enabled
    if (enableMem0 && dbCredentialsSecret && dbConnectionSecret) {
      taskRoleSecretsManagerResources.push(dbCredentialsSecret.secretArn, dbConnectionSecret.secretArn);
    }

    taskRole.addToPolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        'secretsmanager:GetSecretValue',
      ],
      resources: taskRoleSecretsManagerResources,
    }));

    // Add S3 permissions for bucket creation and write operations
    // S3 ARN format differs between global and China regions
    const s3ArnPrefix = isChinaRegion ? 'arn:aws-cn:s3:::' : 'arn:aws:s3:::';
    
    taskRole.addToPolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        's3:CreateBucket',
        's3:PutBucketPolicy',
        's3:PutBucketAcl',
        's3:PutBucketCors',
        's3:PutBucketNotification',
        's3:PutBucketTagging',
        's3:PutBucketVersioning',
        's3:PutBucketLogging',
        's3:ListBucket',
        's3:ListAllMyBuckets',
      ],
      resources: [`${s3ArnPrefix}*`], // For bucket operations with correct ARN format
    }));

    taskRole.addToPolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        's3:PutObject',
        's3:PutObjectAcl',
        's3:PutObjectTagging',
        's3:GetObject',
        's3:GetObjectAcl',
        's3:DeleteObject',
        's3:AbortMultipartUpload',
        's3:ListMultipartUploadParts',
      ],
      resources: [`${s3ArnPrefix}*/*`], // For object operations with correct ARN format
    }));

    // 12. Create Frontend Task Definition
    const frontendTaskDefinition = new ecs.FargateTaskDefinition(this, `${prefix}-frontend-task`, {
      memoryLimitMiB: 512*2,
      cpu: 256*2,
      taskRole: taskRole,
      executionRole: taskExecutionRole,
      runtimePlatform: {
        cpuArchitecture: cpuArchitecture,
        operatingSystemFamily: ecs.OperatingSystemFamily.LINUX,
      },
    });

    const frontendContainer = frontendTaskDefinition.addContainer(`${prefix}-frontend-container`, {
      image: ecs.ContainerImage.fromEcrRepository(frontendRepo, 'latest'),
      memoryLimitMiB: 512,
      environment: {
        NODE_ENV: 'production',
        SERVER_MCP_BASE_URL: `http://${this.alb.loadBalancerDnsName}`,
        NEXT_PUBLIC_MCP_BASE_URL: '/api',
        
      },
      secrets: {
        NEXT_PUBLIC_API_KEY: ecs.Secret.fromSecretsManager(apiKeySecret,'api_key')
      },
      logging: ecs.LogDrivers.awsLogs({
        streamPrefix: 'ecs',
        logGroup: frontendLogGroup,
      }),
      healthCheck: {
        command: ['CMD-SHELL', 'curl -f http://localhost:3000/chat || exit 1'],
        interval: cdk.Duration.seconds(30),
        timeout: cdk.Duration.seconds(5),
        retries: 3,
        startPeriod: cdk.Duration.seconds(60),
      },
    });

    frontendContainer.addPortMappings({
      containerPort: 3000,
      protocol: ecs.Protocol.TCP,
    });

    // 13. Create Backend Task Definition
    const backendTaskDefinition = new ecs.FargateTaskDefinition(this, `${prefix}-backend-task`, {
      memoryLimitMiB: 1024*4,
      cpu: 512*4,
      executionRole: taskExecutionRole,
      taskRole: taskRole,
      runtimePlatform: {
        cpuArchitecture: cpuArchitecture,
        operatingSystemFamily: ecs.OperatingSystemFamily.LINUX,
      },
    });

    // Prepare backend container environment variables
    const backendEnvironment: { [key: string]: string } = {
      AWS_REGION: cdk.Stack.of(this).region,
      STRANDS_MODEL_PROVIDER: process.env.STRANDS_MODEL_PROVIDER||'bedrock',
      MAX_TURNS: '200',
      INACTIVE_TIME: process.env.INACTIVE_TIME||'1440',
      CLIENT_TYPE: 'strands',
      LOG_DIR: './logs',
      MCP_SERVICE_HOST: '0.0.0.0',
      MCP_SERVICE_PORT: '7002',
      USE_HTTPS: '0',
      ddb_table: userConfigTable.tableName,
      LANGFUSE_HOST: process.env.LANGFUSE_HOST||'',
      LANGFUSE_PUBLIC_KEY: process.env.LANGFUSE_PUBLIC_KEY || "",
      LANGFUSE_SECRET_KEY: process.env.LANGFUSE_SECRET_KEY || "",
      BYPASS_TOOL_CONSENT: 'true',
      BEDROCK_AWS_REGION:process.env.BEDROCK_AWS_REGION || process.env.AWS_REGION || "",
      LLM_MODEL: process.env.LLM_MODEL||"Qwen/Qwen3-14B",
      EMBEDDING_MODEL: process.env.EMBEDDING_MODEL ||"Pro/BAAI/bge-m3"
    };

    // Add Aurora-specific environment variables only if Mem0 is enabled
    if (enableMem0 && auroraCluster) {
      backendEnvironment.POSTGRESQL_HOST = auroraCluster.clusterEndpoint.hostname;
      backendEnvironment.POSTGRESQL_PORT = auroraCluster.clusterEndpoint.port.toString();
      backendEnvironment.DB_NAME = 'mcpapp';
    }

    // Prepare backend container secrets
    const backendSecrets: { [key: string]: ecs.Secret } = {
      API_KEY: ecs.Secret.fromSecretsManager(apiKeySecret,'api_key'),
      AWS_ACCESS_KEY_ID: ecs.Secret.fromSecretsManager(awsCredentialsSecret, 'AccessKeyId'),
      AWS_SECRET_ACCESS_KEY: ecs.Secret.fromSecretsManager(awsCredentialsSecret, 'SecretAccessKey'),
      BEDROCK_AWS_ACCESS_KEY_ID: ecs.Secret.fromSecretsManager(bedrockAwsCredentialsSecret, 'AccessKeyId'),
      BEDROCK_AWS_SECRET_ACCESS_KEY:  ecs.Secret.fromSecretsManager(bedrockAwsCredentialsSecret, 'SecretAccessKey'),
      OPENAI_API_KEY: ecs.Secret.fromSecretsManager(strandsApiKeySecret),
      OPENAI_BASE_URL: ecs.Secret.fromSecretsManager(strandsApiBaseSecret),
    };

    // Add Aurora-specific secrets only if Mem0 is enabled
    if (enableMem0 && dbCredentialsSecret) {
      backendSecrets.POSTGRESQL_USER = ecs.Secret.fromSecretsManager(dbCredentialsSecret,'username');
      backendSecrets.POSTGRESQL_PASSWORD = ecs.Secret.fromSecretsManager(dbCredentialsSecret,'password');
    }

    const backendContainer = backendTaskDefinition.addContainer(`${prefix}-backend-container`, {
      image: ecs.ContainerImage.fromEcrRepository(backendRepo, 'latest'),
      memoryLimitMiB: 1024*4,
      environment: backendEnvironment,
      secrets: backendSecrets,
      logging: ecs.LogDrivers.awsLogs({
        streamPrefix: 'ecs',
        logGroup: backendLogGroup,
      }),
      healthCheck: {
        command: ['CMD-SHELL', 'curl -f http://localhost:7002/api/health || exit 1'],
        interval: cdk.Duration.seconds(30),
        timeout: cdk.Duration.seconds(5),
        retries: 3,
        startPeriod: cdk.Duration.seconds(60),
      },
    });

    backendContainer.addPortMappings({
      containerPort: 7002,
      protocol: ecs.Protocol.TCP,
    });

    // 14. Create ECS Services
    const frontendService = new ecs.FargateService(this, `${prefix}-frontend-service`, {
      cluster: this.cluster,
      taskDefinition: frontendTaskDefinition,
      desiredCount: 2,
      assignPublicIp: false,
      vpcSubnets: {
        subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
      },
      securityGroups: [ecsSecurityGroup],
      platformVersion: ecs.FargatePlatformVersion.LATEST,
    });

    const backendService = new ecs.FargateService(this, `${prefix}-backend-service`, {
      cluster: this.cluster,
      taskDefinition: backendTaskDefinition,
      desiredCount: 2,
      assignPublicIp: false,
      vpcSubnets: {
        subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
      },
      securityGroups: [ecsSecurityGroup],
      platformVersion: ecs.FargatePlatformVersion.LATEST,
    });

    // 15. Attach services to target groups
    frontendService.attachToApplicationTargetGroup(frontendTargetGroup);
    backendService.attachToApplicationTargetGroup(backendTargetGroup);

    // 16. Enable Auto Scaling for services
    const frontendScaling = frontendService.autoScaleTaskCount({
      minCapacity: 2,
      maxCapacity: 10,
    });

    frontendScaling.scaleOnCpuUtilization(`${prefix}-frontend-cpu-scaling`, {
      targetUtilizationPercent: 70,
      scaleInCooldown: cdk.Duration.seconds(300),
      scaleOutCooldown: cdk.Duration.seconds(300),
    });

    const backendScaling = backendService.autoScaleTaskCount({
      minCapacity: 2,
      maxCapacity: 10,
    });

    backendScaling.scaleOnCpuUtilization(`${prefix}-backend-cpu-scaling`, {
      targetUtilizationPercent: 70,
      scaleInCooldown: cdk.Duration.seconds(300),
      scaleOutCooldown: cdk.Duration.seconds(300),
    });

    // 17. Stack Outputs
    new cdk.CfnOutput(this, 'VpcId', {
      value: this.vpc.vpcId,
      description: 'VPC ID',
    });

    new cdk.CfnOutput(this, 'ClusterName', {
      value: this.cluster.clusterName,
      description: 'ECS Cluster Name',
    });

    new cdk.CfnOutput(this, 'AlbDnsName', {
      value: this.alb.loadBalancerDnsName,
      description: 'Application Load Balancer DNS Name',
    });

    new cdk.CfnOutput(this, 'FrontendUrl', {
      value: `http://${this.alb.loadBalancerDnsName}`,
      description: 'Frontend Application URL',
    });

    new cdk.CfnOutput(this, 'BackendApiUrl', {
      value: `http://${this.alb.loadBalancerDnsName}/api`,
      description: 'Backend API URL',
    });

    new cdk.CfnOutput(this, 'DynamoDbTableName', {
      value: userConfigTable.tableName,
      description: 'DynamoDB Table Name',
    });

    new cdk.CfnOutput(this, 'FrontendEcrRepository', {
      value: frontendRepo.repositoryUri,
      description: 'Frontend ECR Repository URI',
    });

    new cdk.CfnOutput(this, 'BackendEcrRepository', {
      value: backendRepo.repositoryUri,
      description: 'Backend ECR Repository URI',
    });

    new cdk.CfnOutput(this, 'SecretsManagerPrefix', {
      value: `${prefix}/`,
      description: 'Secrets Manager secrets prefix',
    });
    // Mem0 Aurora-specific outputs (conditional)
    if (enableMem0 && auroraCluster) {
      new cdk.CfnOutput(this, 'AuroraClusterEndpoint', {
        value: auroraCluster.clusterEndpoint.hostname,
        description: 'Aurora PostgreSQL cluster endpoint',
      });

      new cdk.CfnOutput(this, 'AuroraClusterPort', {
        value: auroraCluster.clusterEndpoint.port.toString(),
        description: 'Aurora PostgreSQL cluster port',
      });

      new cdk.CfnOutput(this, 'DatabaseName', {
        value: 'mcpapp',
        description: 'Aurora PostgreSQL database name',
      });
    }
  }
}
